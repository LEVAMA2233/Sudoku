#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include<string.h>

#define P printf
#define S scanf

struct juego {
    int tablero[9][9];
    char nombre[30];//nombre del jugador
};

typedef struct juego JUEGO;

int menu(int x,char[]); 
void establecer_tablero(JUEGO *juego, int tablero_inicial[9][9]);
void imprimir_tablero(const JUEGO *juego); 
bool verificaCasilla_ingresada(const JUEGO *juego, int fil, int col, int num);
void ingresaNum(JUEGO *juego);
void guardarPartida(JUEGO *,int, int *, const JUEGO *,char[30]);

void rotaTablero(JUEGO *,int[9][9]);

int main() {
    JUEGO j;
    int opcion,numJugadores,i=0;
    char player[30];
    int tablero_inicial[9][9] = {
        {5, 0, 0, 0, 7, 0, 0, 0, 0},
        {6, 0, 0, 1, 9, 5, 0, 0, 0},
        {0, 9, 8, 0, 0, 0, 0, 6, 0},
        {8, 0, 0, 0, 6, 0, 0, 0, 3},
        {4, 0, 0, 8, 0, 3, 0, 0, 1},
        {7, 0, 0, 0, 2, 0, 0, 0, 6},
        {0, 6, 0, 0, 0, 0, 2, 8, 0},
        {0, 0, 0, 4, 1, 9, 0, 0, 5},
        {0, 0, 0, 0, 8, 0, 0, 7, 9}
    };
    P("¿Cuantos jugadores son?: ");S("%d",&numJugadores);
    
    JUEGO *partidas=(JUEGO *)malloc(numJugadores*sizeof(JUEGO));//Asignamos un arreglo de estructuras dinámico
    if(partidas==NULL){
    	P("Surgio un error en la asignacion de memoria.");
    	return 1;
	}
	establecer_tablero(&j,tablero_inicial);
	imprimir_tablero(&j);
	P("Nombre del jugador %d: ",i+1);S("%s",partidas[i].nombre);
	strcpy(player,partidas[i].nombre);
	opcion=menu(i,player);

	
	while(opcion!=6){
		switch(opcion){
			case 1:
				ingresaNum(&j);
				break;
			case 2:
				P("\nSeleccionaste imprimir tablero\n");
				P("//////////////////////////////////\n");
				imprimir_tablero(&j);
				break;
			case 3:
				guardarPartida(partidas,i,&i,&j,partidas[i].nombre);
				P("Ingrese el nombre del nuevo jugador: ");S("%s",&partidas[i].nombre);
				strcpy(player,partidas[i].nombre);
				system("cls");
				P("El juego se ha reiniciado para el nuevo jugador.\n");
				establecer_tablero(&j,tablero_inicial);//Reiniciamos al tablero inicial
				break;
			case 4:
				system("cls");
				break;
			case 5:
				rotaTablero(&j,tablero_inicial);
				P("Tu tablero ha sido rotado.\n");
				break;
			case 6:
				return 0;
		}
		opcion=menu(i,player);
	}

    return 0;
}

int menu(int x,char nombre[30]){
	int opc;
	P("Bienvenido al Sudoku! %s\n",nombre);
    P("\nPresione el numero indicado en las opciones del menu, presione 4 para guardar y salir.\n");
	P("\nMENU DE JUEGO:\n 1-$ Ingresa valor al tablero.\n2-$ Imprimir estado actual del juego\n3-$ Guardar partida\n"
	"4-$ Borrar pantalla\n5-$ Rotar tablero.\n ");
	P("$:");S("%d",&opc);
	return opc;
}

void establecer_tablero(JUEGO *juego, int tablero_inicial[9][9]) {
    // Establecer el tablero inicial con los valores proporcionados
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            juego->tablero[i][j] = tablero_inicial[i][j];
        }
    }
}

void imprimir_tablero(const JUEGO *juego) {
    P("Tablero:\n");
    P("1 2 3 4 5 6 7 8 9\n"
	"- - - - - - - - -\n");
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            P("%d ", juego->tablero[i][j]);
        }
        P(" |%d\n", i+1);
    }
}

bool verificaCasilla_ingresada(const JUEGO *juego, int fil, int col, int num) {
    // Verificar la fila y la columna
    for (int i = 0; i < 9; i++) {
        if (juego->tablero[fil-1][i] == num || juego->tablero[i][col-1] == num) {
            return false; // Número repetido encontrado en la fila o columna
        }
    }
    // Verificar el cuadrante 3x3
    int inicioFila = (fil-1) - (fil-1) % 3;
    int inicioCol = (col-1) - (col-1) % 3;
    for (int i = inicioFila; i < inicioFila + 3; i++) {
        for (int j = inicioCol; j < inicioCol + 3; j++) {
            if (juego->tablero[i][j] == num) {
                return false; // Número repetido encontrado en el cuadrante 3x3
            }
        }
    }

    return true; 
}

void ingresaNum(JUEGO *juego) {
    int fila, columna, valor;

        P("\nIngrese la fila (1-9):");
        S("%d", &fila);
        P("Ingresa la columna (1-9):");
        S("%d",&columna);
        P("Ingrese el numero para la casilla (%d,%d)",fila,columna);
        S("%d",&valor);
        if (fila < 1 || fila > 9 || columna < 1 || columna > 9 || valor < 1 || valor > 9) {
            P("Entrada no valida. Por favor, ingrese valores validos.\n");
            
        }

        if (juego->tablero[fila - 1][columna - 1] == 0 && verificaCasilla_ingresada(juego, fila - 1, columna - 1, valor)) {
            juego->tablero[fila - 1][columna - 1] = valor;
            P("Numero agregado exitosamente.\n");
            P("--------------------------------\n");
        } else {
            P("Numero no valido o casilla ocupada. Por favor, ingrese otro valor.\n");
        }
}

void guardarPartida(JUEGO *partidas,int a,int *partidasGuardadas, const JUEGO *juego,char nombre[30]) {
    partidas[*partidasGuardadas] = *juego; // Guardar el estado actual del juego en el arreglo de partidas
    (*partidasGuardadas)++; // Incrementar el contador de partidas guardadas, cambiamos el valor de i que esta en el main
    strcpy(partidas[a].nombre, nombre);
    P("Partida guardada exitosamente.\n");
}

void rotaTablero(JUEGO *juego,int tabInicial[9][9]){
	for(int i=8;i>=0;i--){
    	for(int j=0;j<9;j++){
    		juego->tablero[j][8-i]=tabInicial[i][j];
		}
	}
}
